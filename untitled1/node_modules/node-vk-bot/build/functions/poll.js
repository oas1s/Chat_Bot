"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rq = require("request-promise-native");
var DEFAULT_DELAY = 1000 / 3;
var LOST_HISTORY_ERROR = 1;
var sleep = function (ms) { return new Promise(function (resolve) { return setTimeout(resolve, ms); }); };
function poll(bot, delay) {
    if (delay === void 0) { delay = DEFAULT_DELAY; }
    return bot.api('groups.getLongPollServer', { group_id: bot.options.group_id })
        .then(function (res) {
        return request(res.server + "?act=a_check&key=" + res.key +
            ("&wait=25&version=1&ts=" + res.ts), delay);
    })
        .catch(function (error) {
        bot.emit('poll-error', error);
        return poll(bot, delay);
    });
    function request(url, delay) {
        return rq(url, { json: true })
            .then(function (res) {
            if (!res || !res.ts || (res.failed && res.failed !== LOST_HISTORY_ERROR))
                throw new Error('response of the Long Poll server isn\'t valid ' +
                    ("(" + JSON.stringify(res) + ")"));
            if (res.failed && res.failed === LOST_HISTORY_ERROR)
                bot.emit('poll-error', new Error('event history went out of date or was partially lost'));
            url = url.replace(/ts=.*/, "ts=" + res.ts);
            if (!res.failed && res.updates && res.updates.length > 0) {
                for (var _i = 0, _a = res.updates; _i < _a.length; _i++) {
                    var update = _a[_i];
                    if (update.type === 'message_new')
                        bot.emit('update', update);
                }
            }
            if (bot._stop)
                return null;
            return delay !== 0
                ? sleep(delay).then(function () { return request(url, delay); })
                : request(url, delay);
        });
    }
}
exports.default = poll;
