"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var rq = require("request-promise-native");
var fs = require("fs");
var stream = require("stream");
var poll_1 = require("./functions/poll");
var builder_1 = require("./decorators/builder");
var Keyboard_1 = require("./Keyboard");
exports.Keyboard = Keyboard_1.default;
exports.KeyboardColor = Keyboard_1.KeyboardColor;
var Bot = (function (_super) {
    __extends(Bot, _super);
    function Bot(options) {
        var _this = _super.call(this) || this;
        _this.options = options;
        _this._events = {};
        _this._userEvents = [];
        _this._stop = false;
        if (!options.token)
            throw new Error('token can\'t be empty');
        if (!options.group_id)
            throw new Error('group_id can\'t be empty');
        if (options.api && Number(options.api.v) < 5.80)
            throw new Error('API version must be > 5.80');
        if (options.controllers && options.controllers.length)
            builder_1.build(_this, options.controllers);
        return _this;
    }
    Bot.prototype.api = function (method, params) {
        if (params === void 0) { params = {}; }
        var o = this.options;
        if (o.api) {
            params.v = params.v || o.api.v || '5.80';
            params.lang = params.lang || o.api.lang;
            if (params.lang == null)
                delete params.lang;
        }
        else
            params.v = params.v || '5.80';
        params.access_token = this.options.token;
        return rq({
            baseUrl: 'https://api.vk.com',
            uri: '/method/' + method,
            form: params,
            method: 'POST',
            json: true
        }).then(function (res) {
            if (/execute/.test(method)) {
                return res;
            }
            else if (res.error) {
                throw res.error;
            }
            return res.response;
        });
    };
    Bot.prototype.send = function (text, peer, params) {
        if (params === void 0) { params = {}; }
        params.message = params.message || text;
        params.peer_id = params.peer_id || peer;
        if (params.keyboard && params.keyboard instanceof Keyboard_1.default) {
            params.keyboard = params.keyboard.toString();
        }
        return this.api('messages.send', params);
    };
    Bot.prototype.processUpdate = function (res) {
        if (res.type === 'message_new')
            return this._update(res);
    };
    Bot.prototype.start = function (poll_delay) {
        this.on('update', this._update);
        poll_1.default(this, poll_delay);
        return this;
    };
    Bot.prototype.stop = function () {
        this._stop = true;
        this.removeListener('update', this._update);
        this._events = {};
        return this;
    };
    Bot.prototype.get = function (pattern, listener) {
        this._userEvents.push({
            pattern: pattern, listener: listener
        });
        return this;
    };
    Bot.prototype.getPayload = function (jsonString, listener) {
        this.on('payload', function (msg, reply) {
            if (JSON.stringify(JSON.parse(msg.payload)) === (jsonString)) {
                listener(msg, reply);
            }
        });
    };
    Bot.prototype.uploadPhoto = function (photo) {
        var _this = this;
        var photoStream;
        if (typeof photo === 'string') {
            photoStream = fs.createReadStream(photo);
        }
        else if (photo instanceof stream.Stream) {
            photoStream = photo;
        }
        return this.api('photos.getMessagesUploadServer')
            .then(function (server) { return rq({
            method: 'POST',
            uri: server.upload_url,
            formData: {
                photo: photoStream
            },
            json: true
        }); })
            .then(function (upload) { return _this.api('photos.saveMessagesPhoto', {
            server: upload.server,
            photo: upload.photo,
            hash: upload.hash
        }); })
            .then(function (photos) { return photos[0]; });
    };
    Bot.prototype._update = function (update) {
        var _this = this;
        if (update.group_id !== this.options.group_id)
            return;
        var msg = update.object || false;
        if (!msg)
            return false;
        var hasAttachments = msg.attachments && msg.attachments.length || false;
        var message = {
            id: msg.id,
            peer_id: msg.peer_id,
            from_id: msg.from_id,
            date: msg.date,
            text: msg.text,
            attachments: msg.attachments,
            important: msg.important,
            conversation_message_id: msg.conversation_message_id,
            fwd_messages: msg.fwd_messages
        };
        var reply = function (text, params) {
            if (params === void 0) { params = {}; }
            return _this.send(text, message.peer_id, params);
        };
        if (msg.payload) {
            message.payload = msg.payload;
            this.emit('payload', msg, reply);
        }
        if (hasAttachments && msg.attachments[0].type === 'sticker')
            return this.emit('sticker', message);
        var isAudioMsg = hasAttachments &&
            msg.attachments[0].type === 'doc' &&
            msg.attachments[0].doc.preview &&
            msg.attachments[0].doc.preview.audio_msg;
        if (isAudioMsg)
            return this.emit('voice', message);
        if (!message.text && !hasAttachments)
            return;
        var ev = this._userEvents.find(function (_a) {
            var pattern = _a.pattern;
            return pattern.test(message.text);
        });
        if (!ev) {
            this.emit('command-notfound', message);
            return;
        }
        ev.listener(message, ev.pattern.exec(message.text), reply);
    };
    return Bot;
}(events_1.EventEmitter));
exports.Bot = Bot;
__export(require("./decorators"));
